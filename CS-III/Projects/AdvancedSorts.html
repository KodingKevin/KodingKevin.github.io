<!DOCTYPE html>
<html lang="en">

  <head>
    <title> Advanced Sorts </title>

    <form>
      <input type="button" value="Back" onclick="history.back()">
    </form>

    <link rel="stylesheet" href="APA7.css";>
  </head>
  
  <div>
    <body>

      <h4>Kevin Li </h4>
      <h4> Allen High school STEAM campus </h4>
      <h4> Mrs. Ben </h4>
      <h4> Computer Science III </h4>
      <h4> 29 August 2023 </h4>
      
      <h3>Merge Sort</h3>
      <p> Merge sort is a recursive algorithm that uses divide and conquer by creating two sorted subarrays to correctly sort a given list of numbers known as an arrays. This is also considered one of the fastest sorting algorithms. For the process the sort will divide the given array into two seperate subarrays and then sort each half of the subarray individually. Once the subarrays are sorted the algorithm will merge the two arrays together into it's original form. It will then check if the given array is sorted correctly. If it's not then it'll repeat the process again until it is correctly sorted.  </p> 
      
      <h3>Quick Sort</h3>
      <p> Similar to Merge sort, Quick sort also uses a divide-and-conquer algorithm, however, it is a bit different. This recursive algorithm is considered more efficient than even merge sort. The first steps of the process would be to choose the highest index value has pivot, which is a choosen value from the array used to compare other values that could potentially be lower or greater. Then second step would be to take two variables to point left and right of the array excluding pivot. Then step 3 and 4 would be to move the left points to the low index and the right points to the high index. Now step 5 and 6 while value at left is less than pivot move right and while value at right is greater than pivot move left. Now step 7 if both step 5 and step 6 does not match swap left and right. Finally, if left is greater or equal to right, the point where they met is the new pivot value. Repeat the process until the array is entirely sorted correctly. </p>
      
      <h3> Heap Sort</h3>
      <p> This is a comparison-based sorting algorithm unlike the other two it is based on Binary Heap data structure. However, it is similar to selection sort but more improved where we first find the minimum element and place the minimum element at the beginning but it does not waste time with a linear-time scan of the unsorted region. Heap sort maintains the unsorted region in a heap data structure to move more quickly finding the largest element in each step. Now for the steps before the sorting to take place it reorders the array elements to satisfy the heap property. Then it uses a binary tree structure to map out the array index where the index is the node's parent, left child branch, or right child branch are simple expressions. </p>

      <h3>Time Complexity</h3>
      <p> Merge sort has a time complexity of O(n log n) for the worst, average, and best cases. The merging steps would take an O(n) time while the overall complexity will be O(n log n). Heap sort time complexity for the worst, average, and best cases are also O(n log n). The construction of heap would take O(n) time and each extractions would take O(log n). Then overall time complexity is O(n log n). Finally, for Quick sort it has an average time complexity of O(n log n) and a time complexity of O(n^2) for worst case. The average time complexity being O(n log n) is due to the balanced partitioning on average. While in the worst case where the pivot selection results in a unbalanced partitions the time complexity is lowered to O(n^2). In conclusion, Heap sort and merge sort both have a consistent O(n log n) time complexity however, heap can have a higher constant factors while merge is more stable and reliable. Quick sort on the other hand has an average case of O(n log n) but is possible to be lowered to O(n^2) in the worst case however, overall performance quick sort will provide the fastest average out of the three sorts.</p> 

      <h3>Space Complexity</h3>
      <p> Heap sort has a space complexity of O(1) and because it operates in place it doesn't require additional memory that grows with the size of the input. Merge sort has a space complexity of O(n) and does require additional space to store the temporary sub-arrays during the sorting process. Quick sort has a space complexity of O(log n) on the average case and O(n) on the worst case. The space complexity of quick sort depends on the depth of the recursive call stacks. In conclusion, Heap sort with a space complexity of O(1) make it an optimal option when memory usage is a concern. Merge sort needing the requirement of additional space for temporary storage can be a drawback in memory-constrained environments comparing to other sorts. While quick sort mainly depends on the balance of partitions and the recursive stacks, So it'll be important to consider the size of the data set and the amount of memory the user have before choosing the sorts.</p>

    </body>
  </div>
</html>
